#define _CRT_SECURE_NO_WARNINGS 1

#include <vector>
#include <iostream>
using namespace std;

//整数数组 nums 按升序排列，数组中的值 互不相同 。
//
//在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为[nums[k], nums[k + 1], ..., nums[n - 1], nums[0], nums[1], ..., nums[k - 1]]（下标 从 0 开始 计数）。例如，[0, 1, 2, 4, 5, 6, 7] 在下标 3 处经旋转后可能变为?[4, 5, 6, 7, 0, 1, 2] 。
//
//    给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回? - 1?。
//
//    你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

struct ListNode {
    int val;
    ListNode* next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode* next) : val(x), next(next) {}
    
};

class Solution {
public:
    int search(vector<int>& nums, int target) {
        for (int i = 0; i < nums.size(); i++)
        {
            if (nums[i] == target)
            {
                return i;
            }
        }
        return -1;
    }

    /*Definition for singly - linked list.
        * struct ListNode {
        *int val;
        *ListNode* next;
        *ListNode() : val(0), next(nullptr) {}
        *ListNode(int x) : val(x), next(nullptr) {}
        *ListNode(int x, ListNode* next) : val(x), next(next) {}
        *
    };
    */
    int getDecimalValue(ListNode* head) {
        int sum = 0;
        int arr[30] = { 0 };
        int count = 0;
        struct ListNode* cur = head;
        while (cur)
        {
            arr[count++] = cur->val;
            cur = cur->next;
        }

        for (int i = 0; i < count; i++)
        {
            sum += arr[i] * pow(2, count - i - 1);
        }
        return sum;

    }
};

int main()
{
    vector<int>nums{4, 5, 6, 7, 0, 1, 2};
    int target = 0;
    Solution sol;
    cout<<sol.search(nums, target)<<endl;
    
    ListNode* head = new ListNode(1);
    ListNode* L1 = new ListNode(0);
    ListNode* L2 = new ListNode(1);

    head->next = L1;
    L1->next = L2;
    L2->next = nullptr;

    cout<<sol.getDecimalValue(head)<<endl;
    return 0;
}